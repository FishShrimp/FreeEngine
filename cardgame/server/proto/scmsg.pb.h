// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scmsg.proto

#ifndef PROTOBUF_scmsg_2eproto__INCLUDED
#define PROTOBUF_scmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_scmsg_2eproto();
void protobuf_AssignDesc_scmsg_2eproto();
void protobuf_ShutdownFile_scmsg_2eproto();

class sc_login_res;
class sc_talk;
class sc_player_data;
class sc_battle_action;
class sc_battle_report;
class scmsg;

// ===================================================================

class sc_login_res : public ::google::protobuf::Message {
 public:
  sc_login_res();
  virtual ~sc_login_res();

  sc_login_res(const sc_login_res& from);

  inline sc_login_res& operator=(const sc_login_res& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_login_res& default_instance();

  void Swap(sc_login_res* other);

  // implements Message ----------------------------------------------

  sc_login_res* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_login_res& from);
  void MergeFrom(const sc_login_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 res = 1;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 1;
  inline ::google::protobuf::int32 res() const;
  inline void set_res(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sc_login_res)
 private:
  inline void set_has_res();
  inline void clear_has_res();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_scmsg_2eproto();
  friend void protobuf_AssignDesc_scmsg_2eproto();
  friend void protobuf_ShutdownFile_scmsg_2eproto();

  void InitAsDefaultInstance();
  static sc_login_res* default_instance_;
};
// -------------------------------------------------------------------

class sc_talk : public ::google::protobuf::Message {
 public:
  sc_talk();
  virtual ~sc_talk();

  sc_talk(const sc_talk& from);

  inline sc_talk& operator=(const sc_talk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_talk& default_instance();

  void Swap(sc_talk* other);

  // implements Message ----------------------------------------------

  sc_talk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_talk& from);
  void MergeFrom(const sc_talk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const void* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional bytes msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:sc_talk)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_;
  ::std::string* msg_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_scmsg_2eproto();
  friend void protobuf_AssignDesc_scmsg_2eproto();
  friend void protobuf_ShutdownFile_scmsg_2eproto();

  void InitAsDefaultInstance();
  static sc_talk* default_instance_;
};
// -------------------------------------------------------------------

class sc_player_data : public ::google::protobuf::Message {
 public:
  sc_player_data();
  virtual ~sc_player_data();

  sc_player_data(const sc_player_data& from);

  inline sc_player_data& operator=(const sc_player_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_player_data& default_instance();

  void Swap(sc_player_data* other);

  // implements Message ----------------------------------------------

  sc_player_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_player_data& from);
  void MergeFrom(const sc_player_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:sc_player_data)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_scmsg_2eproto();
  friend void protobuf_AssignDesc_scmsg_2eproto();
  friend void protobuf_ShutdownFile_scmsg_2eproto();

  void InitAsDefaultInstance();
  static sc_player_data* default_instance_;
};
// -------------------------------------------------------------------

class sc_battle_action : public ::google::protobuf::Message {
 public:
  sc_battle_action();
  virtual ~sc_battle_action();

  sc_battle_action(const sc_battle_action& from);

  inline sc_battle_action& operator=(const sc_battle_action& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_battle_action& default_instance();

  void Swap(sc_battle_action* other);

  // implements Message ----------------------------------------------

  sc_battle_action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_battle_action& from);
  void MergeFrom(const sc_battle_action& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 act = 1;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 1;
  inline ::google::protobuf::int32 act() const;
  inline void set_act(::google::protobuf::int32 value);

  // optional int32 from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);

  // optional int32 to = 3;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 3;
  inline ::google::protobuf::int32 to() const;
  inline void set_to(::google::protobuf::int32 value);

  // optional int32 value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sc_battle_action)
 private:
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 act_;
  ::google::protobuf::int32 from_;
  ::google::protobuf::int32 to_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_scmsg_2eproto();
  friend void protobuf_AssignDesc_scmsg_2eproto();
  friend void protobuf_ShutdownFile_scmsg_2eproto();

  void InitAsDefaultInstance();
  static sc_battle_action* default_instance_;
};
// -------------------------------------------------------------------

class sc_battle_report : public ::google::protobuf::Message {
 public:
  sc_battle_report();
  virtual ~sc_battle_report();

  sc_battle_report(const sc_battle_report& from);

  inline sc_battle_report& operator=(const sc_battle_report& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sc_battle_report& default_instance();

  void Swap(sc_battle_report* other);

  // implements Message ----------------------------------------------

  sc_battle_report* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sc_battle_report& from);
  void MergeFrom(const sc_battle_report& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 lchar = 1;
  inline int lchar_size() const;
  inline void clear_lchar();
  static const int kLcharFieldNumber = 1;
  inline ::google::protobuf::int32 lchar(int index) const;
  inline void set_lchar(int index, ::google::protobuf::int32 value);
  inline void add_lchar(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lchar() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lchar();

  // repeated int32 rchar = 2;
  inline int rchar_size() const;
  inline void clear_rchar();
  static const int kRcharFieldNumber = 2;
  inline ::google::protobuf::int32 rchar(int index) const;
  inline void set_rchar(int index, ::google::protobuf::int32 value);
  inline void add_rchar(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      rchar() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_rchar();

  // repeated .sc_battle_action actions = 3;
  inline int actions_size() const;
  inline void clear_actions();
  static const int kActionsFieldNumber = 3;
  inline const ::sc_battle_action& actions(int index) const;
  inline ::sc_battle_action* mutable_actions(int index);
  inline ::sc_battle_action* add_actions();
  inline const ::google::protobuf::RepeatedPtrField< ::sc_battle_action >&
      actions() const;
  inline ::google::protobuf::RepeatedPtrField< ::sc_battle_action >*
      mutable_actions();

  // @@protoc_insertion_point(class_scope:sc_battle_report)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lchar_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > rchar_;
  ::google::protobuf::RepeatedPtrField< ::sc_battle_action > actions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_scmsg_2eproto();
  friend void protobuf_AssignDesc_scmsg_2eproto();
  friend void protobuf_ShutdownFile_scmsg_2eproto();

  void InitAsDefaultInstance();
  static sc_battle_report* default_instance_;
};
// -------------------------------------------------------------------

class scmsg : public ::google::protobuf::Message {
 public:
  scmsg();
  virtual ~scmsg();

  scmsg(const scmsg& from);

  inline scmsg& operator=(const scmsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scmsg& default_instance();

  void Swap(scmsg* other);

  // implements Message ----------------------------------------------

  scmsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scmsg& from);
  void MergeFrom(const scmsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sc_login_res login_res = 1;
  inline bool has_login_res() const;
  inline void clear_login_res();
  static const int kLoginResFieldNumber = 1;
  inline const ::sc_login_res& login_res() const;
  inline ::sc_login_res* mutable_login_res();
  inline ::sc_login_res* release_login_res();
  inline void set_allocated_login_res(::sc_login_res* login_res);

  // optional .sc_talk talk = 2;
  inline bool has_talk() const;
  inline void clear_talk();
  static const int kTalkFieldNumber = 2;
  inline const ::sc_talk& talk() const;
  inline ::sc_talk* mutable_talk();
  inline ::sc_talk* release_talk();
  inline void set_allocated_talk(::sc_talk* talk);

  // optional .sc_player_data player_data = 3;
  inline bool has_player_data() const;
  inline void clear_player_data();
  static const int kPlayerDataFieldNumber = 3;
  inline const ::sc_player_data& player_data() const;
  inline ::sc_player_data* mutable_player_data();
  inline ::sc_player_data* release_player_data();
  inline void set_allocated_player_data(::sc_player_data* player_data);

  // optional .sc_battle_report battle_report = 4;
  inline bool has_battle_report() const;
  inline void clear_battle_report();
  static const int kBattleReportFieldNumber = 4;
  inline const ::sc_battle_report& battle_report() const;
  inline ::sc_battle_report* mutable_battle_report();
  inline ::sc_battle_report* release_battle_report();
  inline void set_allocated_battle_report(::sc_battle_report* battle_report);

  // @@protoc_insertion_point(class_scope:scmsg)
 private:
  inline void set_has_login_res();
  inline void clear_has_login_res();
  inline void set_has_talk();
  inline void clear_has_talk();
  inline void set_has_player_data();
  inline void clear_has_player_data();
  inline void set_has_battle_report();
  inline void clear_has_battle_report();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sc_login_res* login_res_;
  ::sc_talk* talk_;
  ::sc_player_data* player_data_;
  ::sc_battle_report* battle_report_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_scmsg_2eproto();
  friend void protobuf_AssignDesc_scmsg_2eproto();
  friend void protobuf_ShutdownFile_scmsg_2eproto();

  void InitAsDefaultInstance();
  static scmsg* default_instance_;
};
// ===================================================================


// ===================================================================

// sc_login_res

// optional int32 res = 1;
inline bool sc_login_res::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_login_res::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_login_res::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_login_res::clear_res() {
  res_ = 0;
  clear_has_res();
}
inline ::google::protobuf::int32 sc_login_res::res() const {
  return res_;
}
inline void sc_login_res::set_res(::google::protobuf::int32 value) {
  set_has_res();
  res_ = value;
}

// -------------------------------------------------------------------

// sc_talk

// optional bytes from = 1;
inline bool sc_talk::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_talk::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_talk::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_talk::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& sc_talk::from() const {
  return *from_;
}
inline void sc_talk::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void sc_talk::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void sc_talk::set_from(const void* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sc_talk::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* sc_talk::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sc_talk::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 type = 2;
inline bool sc_talk::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sc_talk::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sc_talk::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sc_talk::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 sc_talk::type() const {
  return type_;
}
inline void sc_talk::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes msg = 3;
inline bool sc_talk::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sc_talk::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sc_talk::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sc_talk::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& sc_talk::msg() const {
  return *msg_;
}
inline void sc_talk::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void sc_talk::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void sc_talk::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sc_talk::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* sc_talk::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sc_talk::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_player_data

// optional bytes data = 1;
inline bool sc_player_data::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_player_data::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_player_data::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_player_data::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& sc_player_data::data() const {
  return *data_;
}
inline void sc_player_data::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void sc_player_data::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void sc_player_data::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sc_player_data::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* sc_player_data::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sc_player_data::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sc_battle_action

// optional int32 act = 1;
inline bool sc_battle_action::has_act() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sc_battle_action::set_has_act() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sc_battle_action::clear_has_act() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sc_battle_action::clear_act() {
  act_ = 0;
  clear_has_act();
}
inline ::google::protobuf::int32 sc_battle_action::act() const {
  return act_;
}
inline void sc_battle_action::set_act(::google::protobuf::int32 value) {
  set_has_act();
  act_ = value;
}

// optional int32 from = 2;
inline bool sc_battle_action::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sc_battle_action::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sc_battle_action::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sc_battle_action::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::google::protobuf::int32 sc_battle_action::from() const {
  return from_;
}
inline void sc_battle_action::set_from(::google::protobuf::int32 value) {
  set_has_from();
  from_ = value;
}

// optional int32 to = 3;
inline bool sc_battle_action::has_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sc_battle_action::set_has_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sc_battle_action::clear_has_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sc_battle_action::clear_to() {
  to_ = 0;
  clear_has_to();
}
inline ::google::protobuf::int32 sc_battle_action::to() const {
  return to_;
}
inline void sc_battle_action::set_to(::google::protobuf::int32 value) {
  set_has_to();
  to_ = value;
}

// optional int32 value = 4;
inline bool sc_battle_action::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sc_battle_action::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sc_battle_action::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sc_battle_action::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 sc_battle_action::value() const {
  return value_;
}
inline void sc_battle_action::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// sc_battle_report

// repeated int32 lchar = 1;
inline int sc_battle_report::lchar_size() const {
  return lchar_.size();
}
inline void sc_battle_report::clear_lchar() {
  lchar_.Clear();
}
inline ::google::protobuf::int32 sc_battle_report::lchar(int index) const {
  return lchar_.Get(index);
}
inline void sc_battle_report::set_lchar(int index, ::google::protobuf::int32 value) {
  lchar_.Set(index, value);
}
inline void sc_battle_report::add_lchar(::google::protobuf::int32 value) {
  lchar_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
sc_battle_report::lchar() const {
  return lchar_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
sc_battle_report::mutable_lchar() {
  return &lchar_;
}

// repeated int32 rchar = 2;
inline int sc_battle_report::rchar_size() const {
  return rchar_.size();
}
inline void sc_battle_report::clear_rchar() {
  rchar_.Clear();
}
inline ::google::protobuf::int32 sc_battle_report::rchar(int index) const {
  return rchar_.Get(index);
}
inline void sc_battle_report::set_rchar(int index, ::google::protobuf::int32 value) {
  rchar_.Set(index, value);
}
inline void sc_battle_report::add_rchar(::google::protobuf::int32 value) {
  rchar_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
sc_battle_report::rchar() const {
  return rchar_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
sc_battle_report::mutable_rchar() {
  return &rchar_;
}

// repeated .sc_battle_action actions = 3;
inline int sc_battle_report::actions_size() const {
  return actions_.size();
}
inline void sc_battle_report::clear_actions() {
  actions_.Clear();
}
inline const ::sc_battle_action& sc_battle_report::actions(int index) const {
  return actions_.Get(index);
}
inline ::sc_battle_action* sc_battle_report::mutable_actions(int index) {
  return actions_.Mutable(index);
}
inline ::sc_battle_action* sc_battle_report::add_actions() {
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sc_battle_action >&
sc_battle_report::actions() const {
  return actions_;
}
inline ::google::protobuf::RepeatedPtrField< ::sc_battle_action >*
sc_battle_report::mutable_actions() {
  return &actions_;
}

// -------------------------------------------------------------------

// scmsg

// optional .sc_login_res login_res = 1;
inline bool scmsg::has_login_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scmsg::set_has_login_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scmsg::clear_has_login_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scmsg::clear_login_res() {
  if (login_res_ != NULL) login_res_->::sc_login_res::Clear();
  clear_has_login_res();
}
inline const ::sc_login_res& scmsg::login_res() const {
  return login_res_ != NULL ? *login_res_ : *default_instance_->login_res_;
}
inline ::sc_login_res* scmsg::mutable_login_res() {
  set_has_login_res();
  if (login_res_ == NULL) login_res_ = new ::sc_login_res;
  return login_res_;
}
inline ::sc_login_res* scmsg::release_login_res() {
  clear_has_login_res();
  ::sc_login_res* temp = login_res_;
  login_res_ = NULL;
  return temp;
}
inline void scmsg::set_allocated_login_res(::sc_login_res* login_res) {
  delete login_res_;
  login_res_ = login_res;
  if (login_res) {
    set_has_login_res();
  } else {
    clear_has_login_res();
  }
}

// optional .sc_talk talk = 2;
inline bool scmsg::has_talk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void scmsg::set_has_talk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void scmsg::clear_has_talk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void scmsg::clear_talk() {
  if (talk_ != NULL) talk_->::sc_talk::Clear();
  clear_has_talk();
}
inline const ::sc_talk& scmsg::talk() const {
  return talk_ != NULL ? *talk_ : *default_instance_->talk_;
}
inline ::sc_talk* scmsg::mutable_talk() {
  set_has_talk();
  if (talk_ == NULL) talk_ = new ::sc_talk;
  return talk_;
}
inline ::sc_talk* scmsg::release_talk() {
  clear_has_talk();
  ::sc_talk* temp = talk_;
  talk_ = NULL;
  return temp;
}
inline void scmsg::set_allocated_talk(::sc_talk* talk) {
  delete talk_;
  talk_ = talk;
  if (talk) {
    set_has_talk();
  } else {
    clear_has_talk();
  }
}

// optional .sc_player_data player_data = 3;
inline bool scmsg::has_player_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void scmsg::set_has_player_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void scmsg::clear_has_player_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void scmsg::clear_player_data() {
  if (player_data_ != NULL) player_data_->::sc_player_data::Clear();
  clear_has_player_data();
}
inline const ::sc_player_data& scmsg::player_data() const {
  return player_data_ != NULL ? *player_data_ : *default_instance_->player_data_;
}
inline ::sc_player_data* scmsg::mutable_player_data() {
  set_has_player_data();
  if (player_data_ == NULL) player_data_ = new ::sc_player_data;
  return player_data_;
}
inline ::sc_player_data* scmsg::release_player_data() {
  clear_has_player_data();
  ::sc_player_data* temp = player_data_;
  player_data_ = NULL;
  return temp;
}
inline void scmsg::set_allocated_player_data(::sc_player_data* player_data) {
  delete player_data_;
  player_data_ = player_data;
  if (player_data) {
    set_has_player_data();
  } else {
    clear_has_player_data();
  }
}

// optional .sc_battle_report battle_report = 4;
inline bool scmsg::has_battle_report() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void scmsg::set_has_battle_report() {
  _has_bits_[0] |= 0x00000008u;
}
inline void scmsg::clear_has_battle_report() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void scmsg::clear_battle_report() {
  if (battle_report_ != NULL) battle_report_->::sc_battle_report::Clear();
  clear_has_battle_report();
}
inline const ::sc_battle_report& scmsg::battle_report() const {
  return battle_report_ != NULL ? *battle_report_ : *default_instance_->battle_report_;
}
inline ::sc_battle_report* scmsg::mutable_battle_report() {
  set_has_battle_report();
  if (battle_report_ == NULL) battle_report_ = new ::sc_battle_report;
  return battle_report_;
}
inline ::sc_battle_report* scmsg::release_battle_report() {
  clear_has_battle_report();
  ::sc_battle_report* temp = battle_report_;
  battle_report_ = NULL;
  return temp;
}
inline void scmsg::set_allocated_battle_report(::sc_battle_report* battle_report) {
  delete battle_report_;
  battle_report_ = battle_report;
  if (battle_report) {
    set_has_battle_report();
  } else {
    clear_has_battle_report();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_scmsg_2eproto__INCLUDED
