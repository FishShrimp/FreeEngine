// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csmsg.proto

#ifndef PROTOBUF_csmsg_2eproto__INCLUDED
#define PROTOBUF_csmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_csmsg_2eproto();
void protobuf_AssignDesc_csmsg_2eproto();
void protobuf_ShutdownFile_csmsg_2eproto();

class cs_connect;
class cs_disconnect;
class cs_login;
class cs_talk;
class cs_buy_hero;
class cs_shop_item;
class cs_charge;
class cs_pack_hero;
class cs_select_teammember;
class cs_challenge_mission;
class cs_friend_add;
class cs_friend_mobility;
class csmsg;

// ===================================================================

class cs_connect : public ::google::protobuf::Message {
 public:
  cs_connect();
  virtual ~cs_connect();

  cs_connect(const cs_connect& from);

  inline cs_connect& operator=(const cs_connect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_connect& default_instance();

  void Swap(cs_connect* other);

  // implements Message ----------------------------------------------

  cs_connect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_connect& from);
  void MergeFrom(const cs_connect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cs_connect)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_connect* default_instance_;
};
// -------------------------------------------------------------------

class cs_disconnect : public ::google::protobuf::Message {
 public:
  cs_disconnect();
  virtual ~cs_disconnect();

  cs_disconnect(const cs_disconnect& from);

  inline cs_disconnect& operator=(const cs_disconnect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_disconnect& default_instance();

  void Swap(cs_disconnect* other);

  // implements Message ----------------------------------------------

  cs_disconnect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_disconnect& from);
  void MergeFrom(const cs_disconnect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cs_disconnect)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_disconnect* default_instance_;
};
// -------------------------------------------------------------------

class cs_login : public ::google::protobuf::Message {
 public:
  cs_login();
  virtual ~cs_login();

  cs_login(const cs_login& from);

  inline cs_login& operator=(const cs_login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_login& default_instance();

  void Swap(cs_login* other);

  // implements Message ----------------------------------------------

  cs_login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_login& from);
  void MergeFrom(const cs_login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:cs_login)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_login* default_instance_;
};
// -------------------------------------------------------------------

class cs_talk : public ::google::protobuf::Message {
 public:
  cs_talk();
  virtual ~cs_talk();

  cs_talk(const cs_talk& from);

  inline cs_talk& operator=(const cs_talk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_talk& default_instance();

  void Swap(cs_talk* other);

  // implements Message ----------------------------------------------

  cs_talk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_talk& from);
  void MergeFrom(const cs_talk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes to = 1;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 1;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const void* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // optional bytes msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:cs_talk)
 private:
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* to_;
  ::std::string* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_talk* default_instance_;
};
// -------------------------------------------------------------------

class cs_buy_hero : public ::google::protobuf::Message {
 public:
  cs_buy_hero();
  virtual ~cs_buy_hero();

  cs_buy_hero(const cs_buy_hero& from);

  inline cs_buy_hero& operator=(const cs_buy_hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_buy_hero& default_instance();

  void Swap(cs_buy_hero* other);

  // implements Message ----------------------------------------------

  cs_buy_hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_buy_hero& from);
  void MergeFrom(const cs_buy_hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 idx = 1;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 1;
  inline ::google::protobuf::int32 idx() const;
  inline void set_idx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cs_buy_hero)
 private:
  inline void set_has_idx();
  inline void clear_has_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_buy_hero* default_instance_;
};
// -------------------------------------------------------------------

class cs_shop_item : public ::google::protobuf::Message {
 public:
  cs_shop_item();
  virtual ~cs_shop_item();

  cs_shop_item(const cs_shop_item& from);

  inline cs_shop_item& operator=(const cs_shop_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_shop_item& default_instance();

  void Swap(cs_shop_item* other);

  // implements Message ----------------------------------------------

  cs_shop_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_shop_item& from);
  void MergeFrom(const cs_shop_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 idx = 1;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 1;
  inline ::google::protobuf::int32 idx() const;
  inline void set_idx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cs_shop_item)
 private:
  inline void set_has_idx();
  inline void clear_has_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_shop_item* default_instance_;
};
// -------------------------------------------------------------------

class cs_charge : public ::google::protobuf::Message {
 public:
  cs_charge();
  virtual ~cs_charge();

  cs_charge(const cs_charge& from);

  inline cs_charge& operator=(const cs_charge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_charge& default_instance();

  void Swap(cs_charge* other);

  // implements Message ----------------------------------------------

  cs_charge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_charge& from);
  void MergeFrom(const cs_charge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 diamond = 1;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 1;
  inline ::google::protobuf::int32 diamond() const;
  inline void set_diamond(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cs_charge)
 private:
  inline void set_has_diamond();
  inline void clear_has_diamond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 diamond_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_charge* default_instance_;
};
// -------------------------------------------------------------------

class cs_pack_hero : public ::google::protobuf::Message {
 public:
  cs_pack_hero();
  virtual ~cs_pack_hero();

  cs_pack_hero(const cs_pack_hero& from);

  inline cs_pack_hero& operator=(const cs_pack_hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_pack_hero& default_instance();

  void Swap(cs_pack_hero* other);

  // implements Message ----------------------------------------------

  cs_pack_hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_pack_hero& from);
  void MergeFrom(const cs_pack_hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);

  // optional int32 slot = 2;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 2;
  inline ::google::protobuf::int32 slot() const;
  inline void set_slot(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cs_pack_hero)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_slot();
  inline void clear_has_slot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 action_;
  ::google::protobuf::int32 slot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_pack_hero* default_instance_;
};
// -------------------------------------------------------------------

class cs_select_teammember : public ::google::protobuf::Message {
 public:
  cs_select_teammember();
  virtual ~cs_select_teammember();

  cs_select_teammember(const cs_select_teammember& from);

  inline cs_select_teammember& operator=(const cs_select_teammember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_select_teammember& default_instance();

  void Swap(cs_select_teammember* other);

  // implements Message ----------------------------------------------

  cs_select_teammember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_select_teammember& from);
  void MergeFrom(const cs_select_teammember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 teamslot = 1;
  inline bool has_teamslot() const;
  inline void clear_teamslot();
  static const int kTeamslotFieldNumber = 1;
  inline ::google::protobuf::int32 teamslot() const;
  inline void set_teamslot(::google::protobuf::int32 value);

  // optional int32 packslot = 2;
  inline bool has_packslot() const;
  inline void clear_packslot();
  static const int kPackslotFieldNumber = 2;
  inline ::google::protobuf::int32 packslot() const;
  inline void set_packslot(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cs_select_teammember)
 private:
  inline void set_has_teamslot();
  inline void clear_has_teamslot();
  inline void set_has_packslot();
  inline void clear_has_packslot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 teamslot_;
  ::google::protobuf::int32 packslot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_select_teammember* default_instance_;
};
// -------------------------------------------------------------------

class cs_challenge_mission : public ::google::protobuf::Message {
 public:
  cs_challenge_mission();
  virtual ~cs_challenge_mission();

  cs_challenge_mission(const cs_challenge_mission& from);

  inline cs_challenge_mission& operator=(const cs_challenge_mission& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_challenge_mission& default_instance();

  void Swap(cs_challenge_mission* other);

  // implements Message ----------------------------------------------

  cs_challenge_mission* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_challenge_mission& from);
  void MergeFrom(const cs_challenge_mission& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cs_challenge_mission)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_challenge_mission* default_instance_;
};
// -------------------------------------------------------------------

class cs_friend_add : public ::google::protobuf::Message {
 public:
  cs_friend_add();
  virtual ~cs_friend_add();

  cs_friend_add(const cs_friend_add& from);

  inline cs_friend_add& operator=(const cs_friend_add& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_friend_add& default_instance();

  void Swap(cs_friend_add* other);

  // implements Message ----------------------------------------------

  cs_friend_add* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_friend_add& from);
  void MergeFrom(const cs_friend_add& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:cs_friend_add)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_friend_add* default_instance_;
};
// -------------------------------------------------------------------

class cs_friend_mobility : public ::google::protobuf::Message {
 public:
  cs_friend_mobility();
  virtual ~cs_friend_mobility();

  cs_friend_mobility(const cs_friend_mobility& from);

  inline cs_friend_mobility& operator=(const cs_friend_mobility& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cs_friend_mobility& default_instance();

  void Swap(cs_friend_mobility* other);

  // implements Message ----------------------------------------------

  cs_friend_mobility* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cs_friend_mobility& from);
  void MergeFrom(const cs_friend_mobility& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);

  // optional int32 idx = 2;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 2;
  inline ::google::protobuf::int32 idx() const;
  inline void set_idx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cs_friend_mobility)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_idx();
  inline void clear_has_idx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 action_;
  ::google::protobuf::int32 idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static cs_friend_mobility* default_instance_;
};
// -------------------------------------------------------------------

class csmsg : public ::google::protobuf::Message {
 public:
  csmsg();
  virtual ~csmsg();

  csmsg(const csmsg& from);

  inline csmsg& operator=(const csmsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csmsg& default_instance();

  void Swap(csmsg* other);

  // implements Message ----------------------------------------------

  csmsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csmsg& from);
  void MergeFrom(const csmsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cs_connect connect = 1;
  inline bool has_connect() const;
  inline void clear_connect();
  static const int kConnectFieldNumber = 1;
  inline const ::cs_connect& connect() const;
  inline ::cs_connect* mutable_connect();
  inline ::cs_connect* release_connect();
  inline void set_allocated_connect(::cs_connect* connect);

  // optional .cs_disconnect disconnect = 2;
  inline bool has_disconnect() const;
  inline void clear_disconnect();
  static const int kDisconnectFieldNumber = 2;
  inline const ::cs_disconnect& disconnect() const;
  inline ::cs_disconnect* mutable_disconnect();
  inline ::cs_disconnect* release_disconnect();
  inline void set_allocated_disconnect(::cs_disconnect* disconnect);

  // optional .cs_login login = 3;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 3;
  inline const ::cs_login& login() const;
  inline ::cs_login* mutable_login();
  inline ::cs_login* release_login();
  inline void set_allocated_login(::cs_login* login);

  // optional .cs_charge charge = 4;
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 4;
  inline const ::cs_charge& charge() const;
  inline ::cs_charge* mutable_charge();
  inline ::cs_charge* release_charge();
  inline void set_allocated_charge(::cs_charge* charge);

  // optional .cs_buy_hero buy_hero = 5;
  inline bool has_buy_hero() const;
  inline void clear_buy_hero();
  static const int kBuyHeroFieldNumber = 5;
  inline const ::cs_buy_hero& buy_hero() const;
  inline ::cs_buy_hero* mutable_buy_hero();
  inline ::cs_buy_hero* release_buy_hero();
  inline void set_allocated_buy_hero(::cs_buy_hero* buy_hero);

  // optional .cs_shop_item shop_item = 6;
  inline bool has_shop_item() const;
  inline void clear_shop_item();
  static const int kShopItemFieldNumber = 6;
  inline const ::cs_shop_item& shop_item() const;
  inline ::cs_shop_item* mutable_shop_item();
  inline ::cs_shop_item* release_shop_item();
  inline void set_allocated_shop_item(::cs_shop_item* shop_item);

  // optional .cs_pack_hero pack_hero = 7;
  inline bool has_pack_hero() const;
  inline void clear_pack_hero();
  static const int kPackHeroFieldNumber = 7;
  inline const ::cs_pack_hero& pack_hero() const;
  inline ::cs_pack_hero* mutable_pack_hero();
  inline ::cs_pack_hero* release_pack_hero();
  inline void set_allocated_pack_hero(::cs_pack_hero* pack_hero);

  // optional .cs_select_teammember select_teammember = 8;
  inline bool has_select_teammember() const;
  inline void clear_select_teammember();
  static const int kSelectTeammemberFieldNumber = 8;
  inline const ::cs_select_teammember& select_teammember() const;
  inline ::cs_select_teammember* mutable_select_teammember();
  inline ::cs_select_teammember* release_select_teammember();
  inline void set_allocated_select_teammember(::cs_select_teammember* select_teammember);

  // optional .cs_challenge_mission challenge_mission = 9;
  inline bool has_challenge_mission() const;
  inline void clear_challenge_mission();
  static const int kChallengeMissionFieldNumber = 9;
  inline const ::cs_challenge_mission& challenge_mission() const;
  inline ::cs_challenge_mission* mutable_challenge_mission();
  inline ::cs_challenge_mission* release_challenge_mission();
  inline void set_allocated_challenge_mission(::cs_challenge_mission* challenge_mission);

  // optional .cs_talk talk = 10;
  inline bool has_talk() const;
  inline void clear_talk();
  static const int kTalkFieldNumber = 10;
  inline const ::cs_talk& talk() const;
  inline ::cs_talk* mutable_talk();
  inline ::cs_talk* release_talk();
  inline void set_allocated_talk(::cs_talk* talk);

  // optional .cs_friend_add friend_add = 11;
  inline bool has_friend_add() const;
  inline void clear_friend_add();
  static const int kFriendAddFieldNumber = 11;
  inline const ::cs_friend_add& friend_add() const;
  inline ::cs_friend_add* mutable_friend_add();
  inline ::cs_friend_add* release_friend_add();
  inline void set_allocated_friend_add(::cs_friend_add* friend_add);

  // optional .cs_friend_mobility friend_mobility = 12;
  inline bool has_friend_mobility() const;
  inline void clear_friend_mobility();
  static const int kFriendMobilityFieldNumber = 12;
  inline const ::cs_friend_mobility& friend_mobility() const;
  inline ::cs_friend_mobility* mutable_friend_mobility();
  inline ::cs_friend_mobility* release_friend_mobility();
  inline void set_allocated_friend_mobility(::cs_friend_mobility* friend_mobility);

  // @@protoc_insertion_point(class_scope:csmsg)
 private:
  inline void set_has_connect();
  inline void clear_has_connect();
  inline void set_has_disconnect();
  inline void clear_has_disconnect();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_buy_hero();
  inline void clear_has_buy_hero();
  inline void set_has_shop_item();
  inline void clear_has_shop_item();
  inline void set_has_pack_hero();
  inline void clear_has_pack_hero();
  inline void set_has_select_teammember();
  inline void clear_has_select_teammember();
  inline void set_has_challenge_mission();
  inline void clear_has_challenge_mission();
  inline void set_has_talk();
  inline void clear_has_talk();
  inline void set_has_friend_add();
  inline void clear_has_friend_add();
  inline void set_has_friend_mobility();
  inline void clear_has_friend_mobility();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::cs_connect* connect_;
  ::cs_disconnect* disconnect_;
  ::cs_login* login_;
  ::cs_charge* charge_;
  ::cs_buy_hero* buy_hero_;
  ::cs_shop_item* shop_item_;
  ::cs_pack_hero* pack_hero_;
  ::cs_select_teammember* select_teammember_;
  ::cs_challenge_mission* challenge_mission_;
  ::cs_talk* talk_;
  ::cs_friend_add* friend_add_;
  ::cs_friend_mobility* friend_mobility_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_csmsg_2eproto();
  friend void protobuf_AssignDesc_csmsg_2eproto();
  friend void protobuf_ShutdownFile_csmsg_2eproto();

  void InitAsDefaultInstance();
  static csmsg* default_instance_;
};
// ===================================================================


// ===================================================================

// cs_connect

// -------------------------------------------------------------------

// cs_disconnect

// -------------------------------------------------------------------

// cs_login

// optional bytes id = 1;
inline bool cs_login::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_login::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_login::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_login::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& cs_login::id() const {
  return *id_;
}
inline void cs_login::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void cs_login::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void cs_login::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_login::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* cs_login::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_login::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// cs_talk

// optional bytes to = 1;
inline bool cs_talk::has_to() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_talk::set_has_to() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_talk::clear_has_to() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_talk::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& cs_talk::to() const {
  return *to_;
}
inline void cs_talk::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void cs_talk::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void cs_talk::set_to(const void* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_talk::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* cs_talk::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_talk::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes msg = 3;
inline bool cs_talk::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_talk::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_talk::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_talk::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& cs_talk::msg() const {
  return *msg_;
}
inline void cs_talk::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void cs_talk::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void cs_talk::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_talk::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* cs_talk::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_talk::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// cs_buy_hero

// optional int32 idx = 1;
inline bool cs_buy_hero::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_buy_hero::set_has_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_buy_hero::clear_has_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_buy_hero::clear_idx() {
  idx_ = 0;
  clear_has_idx();
}
inline ::google::protobuf::int32 cs_buy_hero::idx() const {
  return idx_;
}
inline void cs_buy_hero::set_idx(::google::protobuf::int32 value) {
  set_has_idx();
  idx_ = value;
}

// -------------------------------------------------------------------

// cs_shop_item

// optional int32 idx = 1;
inline bool cs_shop_item::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_shop_item::set_has_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_shop_item::clear_has_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_shop_item::clear_idx() {
  idx_ = 0;
  clear_has_idx();
}
inline ::google::protobuf::int32 cs_shop_item::idx() const {
  return idx_;
}
inline void cs_shop_item::set_idx(::google::protobuf::int32 value) {
  set_has_idx();
  idx_ = value;
}

// -------------------------------------------------------------------

// cs_charge

// optional int32 diamond = 1;
inline bool cs_charge::has_diamond() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_charge::set_has_diamond() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_charge::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_charge::clear_diamond() {
  diamond_ = 0;
  clear_has_diamond();
}
inline ::google::protobuf::int32 cs_charge::diamond() const {
  return diamond_;
}
inline void cs_charge::set_diamond(::google::protobuf::int32 value) {
  set_has_diamond();
  diamond_ = value;
}

// -------------------------------------------------------------------

// cs_pack_hero

// optional int32 action = 1;
inline bool cs_pack_hero::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_pack_hero::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_pack_hero::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_pack_hero::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 cs_pack_hero::action() const {
  return action_;
}
inline void cs_pack_hero::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// optional int32 slot = 2;
inline bool cs_pack_hero::has_slot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_pack_hero::set_has_slot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_pack_hero::clear_has_slot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_pack_hero::clear_slot() {
  slot_ = 0;
  clear_has_slot();
}
inline ::google::protobuf::int32 cs_pack_hero::slot() const {
  return slot_;
}
inline void cs_pack_hero::set_slot(::google::protobuf::int32 value) {
  set_has_slot();
  slot_ = value;
}

// -------------------------------------------------------------------

// cs_select_teammember

// optional int32 teamslot = 1;
inline bool cs_select_teammember::has_teamslot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_select_teammember::set_has_teamslot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_select_teammember::clear_has_teamslot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_select_teammember::clear_teamslot() {
  teamslot_ = 0;
  clear_has_teamslot();
}
inline ::google::protobuf::int32 cs_select_teammember::teamslot() const {
  return teamslot_;
}
inline void cs_select_teammember::set_teamslot(::google::protobuf::int32 value) {
  set_has_teamslot();
  teamslot_ = value;
}

// optional int32 packslot = 2;
inline bool cs_select_teammember::has_packslot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_select_teammember::set_has_packslot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_select_teammember::clear_has_packslot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_select_teammember::clear_packslot() {
  packslot_ = 0;
  clear_has_packslot();
}
inline ::google::protobuf::int32 cs_select_teammember::packslot() const {
  return packslot_;
}
inline void cs_select_teammember::set_packslot(::google::protobuf::int32 value) {
  set_has_packslot();
  packslot_ = value;
}

// -------------------------------------------------------------------

// cs_challenge_mission

// optional int32 type = 1;
inline bool cs_challenge_mission::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_challenge_mission::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_challenge_mission::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_challenge_mission::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 cs_challenge_mission::type() const {
  return type_;
}
inline void cs_challenge_mission::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 level = 2;
inline bool cs_challenge_mission::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_challenge_mission::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_challenge_mission::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_challenge_mission::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 cs_challenge_mission::level() const {
  return level_;
}
inline void cs_challenge_mission::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// cs_friend_add

// optional bytes name = 1;
inline bool cs_friend_add::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_friend_add::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_friend_add::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_friend_add::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& cs_friend_add::name() const {
  return *name_;
}
inline void cs_friend_add::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cs_friend_add::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cs_friend_add::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cs_friend_add::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* cs_friend_add::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cs_friend_add::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// cs_friend_mobility

// optional int32 action = 1;
inline bool cs_friend_mobility::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cs_friend_mobility::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cs_friend_mobility::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cs_friend_mobility::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 cs_friend_mobility::action() const {
  return action_;
}
inline void cs_friend_mobility::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// optional int32 idx = 2;
inline bool cs_friend_mobility::has_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cs_friend_mobility::set_has_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cs_friend_mobility::clear_has_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cs_friend_mobility::clear_idx() {
  idx_ = 0;
  clear_has_idx();
}
inline ::google::protobuf::int32 cs_friend_mobility::idx() const {
  return idx_;
}
inline void cs_friend_mobility::set_idx(::google::protobuf::int32 value) {
  set_has_idx();
  idx_ = value;
}

// -------------------------------------------------------------------

// csmsg

// optional .cs_connect connect = 1;
inline bool csmsg::has_connect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csmsg::set_has_connect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csmsg::clear_has_connect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csmsg::clear_connect() {
  if (connect_ != NULL) connect_->::cs_connect::Clear();
  clear_has_connect();
}
inline const ::cs_connect& csmsg::connect() const {
  return connect_ != NULL ? *connect_ : *default_instance_->connect_;
}
inline ::cs_connect* csmsg::mutable_connect() {
  set_has_connect();
  if (connect_ == NULL) connect_ = new ::cs_connect;
  return connect_;
}
inline ::cs_connect* csmsg::release_connect() {
  clear_has_connect();
  ::cs_connect* temp = connect_;
  connect_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_connect(::cs_connect* connect) {
  delete connect_;
  connect_ = connect;
  if (connect) {
    set_has_connect();
  } else {
    clear_has_connect();
  }
}

// optional .cs_disconnect disconnect = 2;
inline bool csmsg::has_disconnect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void csmsg::set_has_disconnect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void csmsg::clear_has_disconnect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void csmsg::clear_disconnect() {
  if (disconnect_ != NULL) disconnect_->::cs_disconnect::Clear();
  clear_has_disconnect();
}
inline const ::cs_disconnect& csmsg::disconnect() const {
  return disconnect_ != NULL ? *disconnect_ : *default_instance_->disconnect_;
}
inline ::cs_disconnect* csmsg::mutable_disconnect() {
  set_has_disconnect();
  if (disconnect_ == NULL) disconnect_ = new ::cs_disconnect;
  return disconnect_;
}
inline ::cs_disconnect* csmsg::release_disconnect() {
  clear_has_disconnect();
  ::cs_disconnect* temp = disconnect_;
  disconnect_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_disconnect(::cs_disconnect* disconnect) {
  delete disconnect_;
  disconnect_ = disconnect;
  if (disconnect) {
    set_has_disconnect();
  } else {
    clear_has_disconnect();
  }
}

// optional .cs_login login = 3;
inline bool csmsg::has_login() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void csmsg::set_has_login() {
  _has_bits_[0] |= 0x00000004u;
}
inline void csmsg::clear_has_login() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void csmsg::clear_login() {
  if (login_ != NULL) login_->::cs_login::Clear();
  clear_has_login();
}
inline const ::cs_login& csmsg::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::cs_login* csmsg::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::cs_login;
  return login_;
}
inline ::cs_login* csmsg::release_login() {
  clear_has_login();
  ::cs_login* temp = login_;
  login_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_login(::cs_login* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .cs_charge charge = 4;
inline bool csmsg::has_charge() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void csmsg::set_has_charge() {
  _has_bits_[0] |= 0x00000008u;
}
inline void csmsg::clear_has_charge() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void csmsg::clear_charge() {
  if (charge_ != NULL) charge_->::cs_charge::Clear();
  clear_has_charge();
}
inline const ::cs_charge& csmsg::charge() const {
  return charge_ != NULL ? *charge_ : *default_instance_->charge_;
}
inline ::cs_charge* csmsg::mutable_charge() {
  set_has_charge();
  if (charge_ == NULL) charge_ = new ::cs_charge;
  return charge_;
}
inline ::cs_charge* csmsg::release_charge() {
  clear_has_charge();
  ::cs_charge* temp = charge_;
  charge_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_charge(::cs_charge* charge) {
  delete charge_;
  charge_ = charge;
  if (charge) {
    set_has_charge();
  } else {
    clear_has_charge();
  }
}

// optional .cs_buy_hero buy_hero = 5;
inline bool csmsg::has_buy_hero() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void csmsg::set_has_buy_hero() {
  _has_bits_[0] |= 0x00000010u;
}
inline void csmsg::clear_has_buy_hero() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void csmsg::clear_buy_hero() {
  if (buy_hero_ != NULL) buy_hero_->::cs_buy_hero::Clear();
  clear_has_buy_hero();
}
inline const ::cs_buy_hero& csmsg::buy_hero() const {
  return buy_hero_ != NULL ? *buy_hero_ : *default_instance_->buy_hero_;
}
inline ::cs_buy_hero* csmsg::mutable_buy_hero() {
  set_has_buy_hero();
  if (buy_hero_ == NULL) buy_hero_ = new ::cs_buy_hero;
  return buy_hero_;
}
inline ::cs_buy_hero* csmsg::release_buy_hero() {
  clear_has_buy_hero();
  ::cs_buy_hero* temp = buy_hero_;
  buy_hero_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_buy_hero(::cs_buy_hero* buy_hero) {
  delete buy_hero_;
  buy_hero_ = buy_hero;
  if (buy_hero) {
    set_has_buy_hero();
  } else {
    clear_has_buy_hero();
  }
}

// optional .cs_shop_item shop_item = 6;
inline bool csmsg::has_shop_item() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void csmsg::set_has_shop_item() {
  _has_bits_[0] |= 0x00000020u;
}
inline void csmsg::clear_has_shop_item() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void csmsg::clear_shop_item() {
  if (shop_item_ != NULL) shop_item_->::cs_shop_item::Clear();
  clear_has_shop_item();
}
inline const ::cs_shop_item& csmsg::shop_item() const {
  return shop_item_ != NULL ? *shop_item_ : *default_instance_->shop_item_;
}
inline ::cs_shop_item* csmsg::mutable_shop_item() {
  set_has_shop_item();
  if (shop_item_ == NULL) shop_item_ = new ::cs_shop_item;
  return shop_item_;
}
inline ::cs_shop_item* csmsg::release_shop_item() {
  clear_has_shop_item();
  ::cs_shop_item* temp = shop_item_;
  shop_item_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_shop_item(::cs_shop_item* shop_item) {
  delete shop_item_;
  shop_item_ = shop_item;
  if (shop_item) {
    set_has_shop_item();
  } else {
    clear_has_shop_item();
  }
}

// optional .cs_pack_hero pack_hero = 7;
inline bool csmsg::has_pack_hero() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void csmsg::set_has_pack_hero() {
  _has_bits_[0] |= 0x00000040u;
}
inline void csmsg::clear_has_pack_hero() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void csmsg::clear_pack_hero() {
  if (pack_hero_ != NULL) pack_hero_->::cs_pack_hero::Clear();
  clear_has_pack_hero();
}
inline const ::cs_pack_hero& csmsg::pack_hero() const {
  return pack_hero_ != NULL ? *pack_hero_ : *default_instance_->pack_hero_;
}
inline ::cs_pack_hero* csmsg::mutable_pack_hero() {
  set_has_pack_hero();
  if (pack_hero_ == NULL) pack_hero_ = new ::cs_pack_hero;
  return pack_hero_;
}
inline ::cs_pack_hero* csmsg::release_pack_hero() {
  clear_has_pack_hero();
  ::cs_pack_hero* temp = pack_hero_;
  pack_hero_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_pack_hero(::cs_pack_hero* pack_hero) {
  delete pack_hero_;
  pack_hero_ = pack_hero;
  if (pack_hero) {
    set_has_pack_hero();
  } else {
    clear_has_pack_hero();
  }
}

// optional .cs_select_teammember select_teammember = 8;
inline bool csmsg::has_select_teammember() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void csmsg::set_has_select_teammember() {
  _has_bits_[0] |= 0x00000080u;
}
inline void csmsg::clear_has_select_teammember() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void csmsg::clear_select_teammember() {
  if (select_teammember_ != NULL) select_teammember_->::cs_select_teammember::Clear();
  clear_has_select_teammember();
}
inline const ::cs_select_teammember& csmsg::select_teammember() const {
  return select_teammember_ != NULL ? *select_teammember_ : *default_instance_->select_teammember_;
}
inline ::cs_select_teammember* csmsg::mutable_select_teammember() {
  set_has_select_teammember();
  if (select_teammember_ == NULL) select_teammember_ = new ::cs_select_teammember;
  return select_teammember_;
}
inline ::cs_select_teammember* csmsg::release_select_teammember() {
  clear_has_select_teammember();
  ::cs_select_teammember* temp = select_teammember_;
  select_teammember_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_select_teammember(::cs_select_teammember* select_teammember) {
  delete select_teammember_;
  select_teammember_ = select_teammember;
  if (select_teammember) {
    set_has_select_teammember();
  } else {
    clear_has_select_teammember();
  }
}

// optional .cs_challenge_mission challenge_mission = 9;
inline bool csmsg::has_challenge_mission() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void csmsg::set_has_challenge_mission() {
  _has_bits_[0] |= 0x00000100u;
}
inline void csmsg::clear_has_challenge_mission() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void csmsg::clear_challenge_mission() {
  if (challenge_mission_ != NULL) challenge_mission_->::cs_challenge_mission::Clear();
  clear_has_challenge_mission();
}
inline const ::cs_challenge_mission& csmsg::challenge_mission() const {
  return challenge_mission_ != NULL ? *challenge_mission_ : *default_instance_->challenge_mission_;
}
inline ::cs_challenge_mission* csmsg::mutable_challenge_mission() {
  set_has_challenge_mission();
  if (challenge_mission_ == NULL) challenge_mission_ = new ::cs_challenge_mission;
  return challenge_mission_;
}
inline ::cs_challenge_mission* csmsg::release_challenge_mission() {
  clear_has_challenge_mission();
  ::cs_challenge_mission* temp = challenge_mission_;
  challenge_mission_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_challenge_mission(::cs_challenge_mission* challenge_mission) {
  delete challenge_mission_;
  challenge_mission_ = challenge_mission;
  if (challenge_mission) {
    set_has_challenge_mission();
  } else {
    clear_has_challenge_mission();
  }
}

// optional .cs_talk talk = 10;
inline bool csmsg::has_talk() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void csmsg::set_has_talk() {
  _has_bits_[0] |= 0x00000200u;
}
inline void csmsg::clear_has_talk() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void csmsg::clear_talk() {
  if (talk_ != NULL) talk_->::cs_talk::Clear();
  clear_has_talk();
}
inline const ::cs_talk& csmsg::talk() const {
  return talk_ != NULL ? *talk_ : *default_instance_->talk_;
}
inline ::cs_talk* csmsg::mutable_talk() {
  set_has_talk();
  if (talk_ == NULL) talk_ = new ::cs_talk;
  return talk_;
}
inline ::cs_talk* csmsg::release_talk() {
  clear_has_talk();
  ::cs_talk* temp = talk_;
  talk_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_talk(::cs_talk* talk) {
  delete talk_;
  talk_ = talk;
  if (talk) {
    set_has_talk();
  } else {
    clear_has_talk();
  }
}

// optional .cs_friend_add friend_add = 11;
inline bool csmsg::has_friend_add() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void csmsg::set_has_friend_add() {
  _has_bits_[0] |= 0x00000400u;
}
inline void csmsg::clear_has_friend_add() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void csmsg::clear_friend_add() {
  if (friend_add_ != NULL) friend_add_->::cs_friend_add::Clear();
  clear_has_friend_add();
}
inline const ::cs_friend_add& csmsg::friend_add() const {
  return friend_add_ != NULL ? *friend_add_ : *default_instance_->friend_add_;
}
inline ::cs_friend_add* csmsg::mutable_friend_add() {
  set_has_friend_add();
  if (friend_add_ == NULL) friend_add_ = new ::cs_friend_add;
  return friend_add_;
}
inline ::cs_friend_add* csmsg::release_friend_add() {
  clear_has_friend_add();
  ::cs_friend_add* temp = friend_add_;
  friend_add_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_friend_add(::cs_friend_add* friend_add) {
  delete friend_add_;
  friend_add_ = friend_add;
  if (friend_add) {
    set_has_friend_add();
  } else {
    clear_has_friend_add();
  }
}

// optional .cs_friend_mobility friend_mobility = 12;
inline bool csmsg::has_friend_mobility() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void csmsg::set_has_friend_mobility() {
  _has_bits_[0] |= 0x00000800u;
}
inline void csmsg::clear_has_friend_mobility() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void csmsg::clear_friend_mobility() {
  if (friend_mobility_ != NULL) friend_mobility_->::cs_friend_mobility::Clear();
  clear_has_friend_mobility();
}
inline const ::cs_friend_mobility& csmsg::friend_mobility() const {
  return friend_mobility_ != NULL ? *friend_mobility_ : *default_instance_->friend_mobility_;
}
inline ::cs_friend_mobility* csmsg::mutable_friend_mobility() {
  set_has_friend_mobility();
  if (friend_mobility_ == NULL) friend_mobility_ = new ::cs_friend_mobility;
  return friend_mobility_;
}
inline ::cs_friend_mobility* csmsg::release_friend_mobility() {
  clear_has_friend_mobility();
  ::cs_friend_mobility* temp = friend_mobility_;
  friend_mobility_ = NULL;
  return temp;
}
inline void csmsg::set_allocated_friend_mobility(::cs_friend_mobility* friend_mobility) {
  delete friend_mobility_;
  friend_mobility_ = friend_mobility;
  if (friend_mobility) {
    set_has_friend_mobility();
  } else {
    clear_has_friend_mobility();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_csmsg_2eproto__INCLUDED
